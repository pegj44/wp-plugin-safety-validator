<?php

namespace WP_PluginSafetyValidator\Modules;

use WP_PluginSafetyValidator\Helpers\FileDownloader;
use WP_PluginSafetyValidator\Interfaces\PluginScannerInterface;
use WP_PluginSafetyValidator\traits\ScanPluginTrait;
use WP_PluginSafetyValidator\Traits\SchedulerTrait;

if (!defined('ABSPATH')) die('Access denied.');

class WordFenceVulnerabilityDataFeed implements PluginScannerInterface
{
    use SchedulerTrait, ScanPluginTrait;

    /**
     * The singleton instance of the WordFenceVulnerabilityDataFeed class
     *
     * @var string
     */
    protected static $_instance;
    private $option_record_key = WP_PLUGIN_SAFETY_VALIDATOR_DOMAIN .'_wf_scan_record';
    private $data_file_source_url = 'https://www.wordfence.com/api/intelligence/v2/vulnerabilities/production';
    private $data_file_name = 'vulnerabilities.production.json';
    private $scan_record = [];

    /**
     * Get the singleton instance of the WordFenceVulnerabilityDataFeed class
     *
     * @return WordFenceVulnerabilityDataFeed
     */
    public static function instance(): WordFenceVulnerabilityDataFeed
    {
        if (empty(self::$_instance)) {
            self::$_instance = new self();
        }

        return self::$_instance;
    }

    public function __construct()
    {
//        $this->register_schedulers();
//
//        add_action( 'current_screen', [$this, 'load_plugin_check_record'] );
    }

    public function load_plugin_check_record( $screen ): void
    {
        if ( $screen && 'plugins' !== $screen->id ) {
            return;
        }

        $GLOBALS['wp_plugin_vulnerabilities']['wordfence'] = get_option($this->option_record_key, []);
    }

    public function scan_plugin($plugin_data, $save_data = true): array
    {
        $this->download_data_feed();

        $json_file_path = WP_CONTENT_DIR . '/uploads/'. WP_PLUGIN_SAFETY_VALIDATOR_DOMAIN . '/'. $this->get_data_feed_file_name();
        $result = WordFenceVulnerabilityDataFeed::check_plugin_vulnerabilities_stream( $plugin_data, $json_file_path );

        if ( $result['vulnerable'] ) {

            $matches = [];

            foreach ( $result['matches'] as $match ) {

                $references = [];

                foreach ( $match['references'] as $reference ) {
                    $parsedUrl = parse_url($reference);
                    $domain = $parsedUrl['host'] ?? null;
                    $references[$domain] = esc_url_raw( wp_unslash($reference) );
                }

                $matches[] = [
                    'title' => $match['title'],
                    'description' => $match['description'],
                    'sources' => $references,
                    'affected_versions' => $match['affected'],
                ];
            }

            if ( $save_data ) {
                $this->save_scan_record($plugin_data['slug'], $matches);
            }

            return $matches;
        }

        return [];
    }

    /**
     * Download the WordFence vulnerability data feed
     *
     * @return true|\WP_Error|string
     */
    public function download_data_feed(): true|\WP_Error|string
    {
        $downloader = new FileDownloader();
        $downloader->set_file_source_url($this->get_data_feed_file_source_url());
        $downloader->set_file_name($this->get_data_feed_file_name());
        $file = $downloader->download();

        return $file;
    }

    public function get_data_feed_file_name(): string
    {
        return $this->data_file_name;
    }

    public function get_data_feed_file_source_url(): string
    {
        return $this->data_file_source_url;
    }

    protected function get_schedules(): array
    {
        return [
            [
                'interval_slug' => 'once_daily',
                'interval_args' => [
                    'interval' => 15,
                    'display' => __('Once daily', WP_PLUGIN_SAFETY_VALIDATOR_DOMAIN),
                ],
                'callback' => 'update_data_feed_file'
            ]
        ];
    }

    public function update_data_feed_file()
    {
        error_log('LOG TEST2');
    }

    /** Get installed plugin version (e.g., 'akismet/akismet.php'). */
    public static function get_installed_plugin_version( $plugin_file ): ?string
    {
        if ( ! function_exists( 'get_plugins' ) ) {
            require_once ABSPATH . 'wp-admin/includes/plugin.php';
        }
        $plugins = get_plugins();
        if ( isset( $plugins[ $plugin_file ]['Version'] ) && $plugins[ $plugin_file ]['Version'] !== '' ) {
            return (string) $plugins[ $plugin_file ]['Version'];
        }
        $full_path = trailingslashit( WP_PLUGIN_DIR ) . ltrim( $plugin_file, '/' );
        if ( file_exists( $full_path ) && function_exists( 'get_plugin_data' ) ) {
            $data = get_plugin_data( $full_path, false, false );
            if ( ! empty( $data['Version'] ) ) {
                return (string) $data['Version'];
            }
        }
        return null;
    }

    /** Version range matcher for software[].affected_versions maps. */
    public static function version_in_affected_ranges( $installed_version, $ranges ): bool
    {
        if ( empty( $installed_version ) || empty( $ranges ) || ! is_array( $ranges ) ) {
            return false;
        }
        foreach ( $ranges as $range ) {
            if ( ! is_array( $range ) ) {
                continue;
            }
            $from      = isset( $range['from_version'] ) ? (string) $range['from_version'] : '*';
            $from_incl = isset( $range['from_inclusive'] ) ? (bool) $range['from_inclusive'] : true;
            $to        = isset( $range['to_version'] ) ? (string) $range['to_version'] : '*';
            $to_incl   = isset( $range['to_inclusive'] ) ? (bool) $range['to_inclusive'] : true;

            $lower_ok = ( '*' === $from ) ? true : ( $from_incl ? version_compare( $installed_version, $from, '>=' ) : version_compare( $installed_version, $from, '>' ) );
            $upper_ok = ( '*' === $to )   ? true : ( $to_incl   ? version_compare( $installed_version, $to, '<=' ) : version_compare( $installed_version, $to, '<' ) );

            if ( $lower_ok && $upper_ok ) {
                return true;
            }
        }
        return false;
    }

    /**
     * STREAM PARSER: iterate each vulnerability item from a huge JSON object without loading all into memory.
     * Expects top-level structure: { "uuid": {item}, "uuid2": {item2}, ... }
     *
     * @param string $json_path
     * @return void Generator yields associative arrays (decoded item objects)
     */
    public static function stream_items(string $json_path ) {
        $fh = @fopen( $json_path, 'rb' );
        if ( ! $fh ) {
            return;
        }

        // Helper lambdas replaced with static private methods for WP standards.
        try {
            self::skip_ws( $fh );
            $first = self::read_char( $fh );
            if ( $first !== '{' ) { fclose( $fh ); return; }

            while ( true ) {
                self::skip_ws( $fh );
                $peek = self::peek_char( $fh );
                if ( $peek === '}' ) { self::read_char( $fh ); break; } // end of object
                if ( $peek === ',' ) { self::read_char( $fh ); self::skip_ws( $fh ); }

                // Read key
                $key = self::read_json_string( $fh ); // we don't use the key, but must consume it
                self::skip_ws( $fh );

                // Expect colon
                $colon = self::read_char( $fh );
                if ( $colon !== ':' ) { break; }
                self::skip_ws( $fh );

                // Read value object by brace-depth tracking
                $val_first = self::peek_char( $fh );
                if ( $val_first !== '{' ) {
                    // Skip non-object values safely (shouldn't happen for this feed)
                    self::read_generic_value( $fh );
                    continue;
                }
                $json_fragment = self::read_balanced_object( $fh ); // includes outer braces
                if ( $json_fragment !== '' ) {
                    $item = json_decode( $json_fragment, true );
                    if ( is_array( $item ) ) {
                        yield $item;
                    }
                }
            }
        } finally {
            fclose( $fh );
        }
    }

    /** Memory-safe check: scans the file stream and matches only the target plugin. */
    public static function check_plugin_vulnerabilities_stream( $plugin_data, $json_path ): array
    {
        $result = [
            'vulnerable'        => false,
            'plugin'            => (string) $plugin_data['slug'],
            'installed_version' => '',
            'matches'           => [],
        ];

        if ( empty($plugin_data['Version']) ) {
            $installed_version = self::get_installed_plugin_version( $plugin_data['plugin_file'] );
        } else {
            $installed_version = $plugin_data['Version'];
        }

        $result['installed_version'] = $installed_version;

        if (empty($plugin_data['slug'])) {
            // Derive slug from plugin directory.
            $slug = trim( dirname( $plugin_data['plugin_file'] ), '/\\' );
            if (str_contains($slug, '/')) {
                $parts = explode( '/', $slug );
                $slug  = reset( $parts );
            }
        } else {
            $slug = $plugin_data['slug'];
        }

        foreach ( self::stream_items( $json_path ) as $item ) {
            if ( empty( $item['software'] ) || ! is_array( $item['software'] ) ) {
                continue;
            }
            foreach ( $item['software'] as $soft ) {
                if ( empty( $soft['type'] ) || 'plugin' !== $soft['type'] || empty( $soft['slug'] ) ) {
                    continue;
                }
                if ( (string) $soft['slug'] !== $slug ) {
                    continue;
                }

                $affected = ( isset( $soft['affected_versions'] ) && is_array( $soft['affected_versions'] ) ) ? $soft['affected_versions'] : [];
                $is_match = ( $installed_version ) ? self::version_in_affected_ranges( $installed_version, $affected ) : false;

                if ( $is_match ) {
                    $result['vulnerable'] = true;
                    $result['matches'][]  = [
                        'id'               => isset( $item['id'] ) ? (string) $item['id'] : '',
                        'title'            => isset( $item['title'] ) ? (string) $item['title'] : '',
                        'description'      => isset( $item['description'] ) ? (string) $item['description'] : '',
                        'references'       => ( ! empty( $item['references'] ) && is_array( $item['references'] ) ) ? array_map( 'esc_url_raw', $item['references'] ) : array(),
                        'slug'             => (string) $soft['slug'],
                        'affected'         => self::normalize_affected_ranges($affected),
                        'patched'          => ! empty( $soft['patched'] ),
                        'patched_versions' => ( ! empty( $soft['patched_versions'] ) && is_array( $soft['patched_versions'] ) ) ? array_map( 'strval', $soft['patched_versions'] ) : array(),
                    ];
                }
            }

             if ( $result['vulnerable'] ) { break; }
        }

        return $result;
    }

    /**
     * Format affected version ranges for display.
     *
     * @param $affected
     * @return array
     */
    private static function normalize_affected_ranges( $affected )
    {
        $out = array();

        // $affected may be either assoc (label => range) or list of ranges.
        foreach ( $affected as $label => $range ) {
            if ( ! is_array( $range ) ) {
                continue;
            }

            $min = isset( $range['from_version'] ) ? (string) $range['from_version'] : '*';
            $max = isset( $range['to_version'] )   ? (string) $range['to_version']   : '*';

            $min_is_any = ( $min === '*' || $min === '' );
            $max_is_any = ( $max === '*' || $max === '' );

            $min_op = $min_is_any ? null : ( ! empty( $range['from_inclusive'] ) ? '>=' : '>' );
            $max_op = $max_is_any ? null : ( ! empty( $range['to_inclusive'] )   ? '<=' : '<' );

            $out[] = array(
                'min_version'   => $min_is_any ? null : $min,
                'max_version'   => $max_is_any ? null : $max,
                'min_operator'  => $min_op, // '>=', '>', or null if unbounded
                'max_operator'  => $max_op, // '<=', '<', or null if unbounded
            );
        }

        return $out;
    }

    private static function read_char( $fh ) {
        return fgetc( $fh );
    }
    private static function peek_char( $fh ) {
        $ch = fgetc( $fh );
        if ( $ch !== false ) {
            fseek( $fh, -1, SEEK_CUR );
        }
        return $ch;
    }
    private static function skip_ws( $fh ) {
        while ( true ) {
            $ch = self::peek_char( $fh );
            if ( $ch === false ) { return; }
            if ( $ch !== ' ' && $ch !== "\t" && $ch !== "\n" && $ch !== "\r" ) { return; }
            self::read_char( $fh );
        }
    }

    /** Read a JSON string token (assumes cursor is at opening quote). Returns unescaped PHP string. */
    private static function read_json_string( $fh ) {
        $quote = self::read_char( $fh );
        if ( $quote !== '"' ) { return ''; }
        $out = '';
        $escaped = false;
        while ( true ) {
            $ch = self::read_char( $fh );
            if ( $ch === false ) { break; }
            if ( $escaped ) {
                $out .= $ch;
                $escaped = false;
            } elseif ( $ch === '\\' ) {
                $out .= $ch;
                $escaped = true;
            } elseif ( $ch === '"' ) {
                break;
            } else {
                $out .= $ch;
            }
        }
        // Decode escape sequences using json_decode on a tiny string.
        $decoded = json_decode( '"' . $out . '"', true );
        return is_string( $decoded ) ? $decoded : $out;
    }

    /** Read an arbitrary JSON value (number, string, true/false/null, array, object) without decoding it; used to skip. */
    private static function read_generic_value( $fh ) {
        self::skip_ws( $fh );
        $ch = self::peek_char( $fh );
        if ( $ch === '"' ) { self::read_json_string( $fh ); return; }
        if ( $ch === '{' ) { self::read_balanced_object( $fh ); return; }
        if ( $ch === '[' ) { self::read_balanced_array( $fh ); return; }
        // Primitives: read until a structural delimiter or whitespace/comma/} or ]
        $buf = '';
        while ( true ) {
            $c = self::peek_char( $fh );
            if ( $c === false ) { break; }
            if ( ctype_space( $c ) || $c === ',' || $c === '}' || $c === ']' ) { break; }
            $buf .= self::read_char( $fh );
        }
    }

    /** Read {...} respecting strings/escapes and nested braces; return the JSON text including braces. */
    private static function read_balanced_object( $fh ) {
        $depth = 0;
        $in_str = false;
        $escaped = false;
        $buf = '';

        while ( true ) {
            $ch = self::read_char( $fh );
            if ( $ch === false ) { break; }
            $buf .= $ch;

            if ( $in_str ) {
                if ( $escaped ) {
                    $escaped = false;
                } elseif ( $ch === '\\' ) {
                    $escaped = true;
                } elseif ( $ch === '"' ) {
                    $in_str = false;
                }
                continue;
            }

            if ( $ch === '"' ) {
                $in_str = true;
                continue;
            }

            if ( $ch === '{' ) {
                $depth++;
            } elseif ( $ch === '}' ) {
                $depth--;
                if ( $depth === 0 ) {
                    break;
                }
            }
        }
        return $buf;
    }

    /** Read [...] respecting strings/escapes and nested brackets (used by read_generic_value). */
    private static function read_balanced_array( $fh ) {
        $depth = 0;
        $in_str = false;
        $escaped = false;
        $buf = '';

        while ( true ) {
            $ch = self::read_char( $fh );
            if ( $ch === false ) { break; }
            $buf .= $ch;

            if ( $in_str ) {
                if ( $escaped ) {
                    $escaped = false;
                } elseif ( $ch === '\\' ) {
                    $escaped = true;
                } elseif ( $ch === '"' ) {
                    $in_str = false;
                }
                continue;
            }

            if ( $ch === '"' ) {
                $in_str = true;
                continue;
            }

            if ( $ch === '[' ) {
                $depth++;
            } elseif ( $ch === ']' ) {
                $depth--;
                if ( $depth === 0 ) {
                    break;
                }
            }
        }
        return $buf;
    }
} // end Class