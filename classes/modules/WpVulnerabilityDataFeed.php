<?php

namespace WP_PluginSafetyValidator\Modules;

if (!defined('ABSPATH')) die('Access denied.');

class WpVulnerabilityDataFeed
{
    protected static $_instance;
    protected $wpvulnerability_base_api_url = 'https://www.wpvulnerability.net/plugin/';
    private $option_record_key = WP_PLUGIN_SAFETY_VALIDATOR_DOMAIN .'_wpv_scan_record';
    /**
     * Get the singleton instance of the WpVulnerabilityDataFeed class
     *
     * @return WpVulnerabilityDataFeed
     */
    public static function instance(): WpVulnerabilityDataFeed
    {
        if (empty(self::$_instance)) {
            self::$_instance = new self();
        }

        return self::$_instance;
    }

    public function __construct()
    {
        add_action( 'current_screen', [$this, 'load_plugin_check_record'] );
    }

    public function load_plugin_check_record( $screen ): void
    {
        if ( $screen && 'plugins' !== $screen->id ) {
            return;
        }

        $GLOBALS['wp_plugin_vulnerabilities']['wpvulnerability'] = get_option($this->option_record_key, []);
    }

    public function scan_plugin($plugin_data, $save_data = true)
    {
        $plugin_slug = $plugin_data['slug'];

        $data = $this->get_plugin_record($plugin_slug);
        $response = $this->check_vulnerabilities($data['data'], $plugin_data['Version']);

        if($save_data) {
            $this->save_scan_record($plugin_slug, $response);
        }

        return $response;
    }

    private function save_scan_record($plugin_slug, $scan_record): void
    {
        if (empty($scan_record)) {
            return;
        }

        $records = get_option( $this->option_record_key, [] );

        $records[$plugin_slug] = $scan_record;

        update_option( $this->option_record_key, $records );
    }

    /**
     * Check if a version is affected and return matching entries.
     * Each entry is built from vulnerability `source[]`.
     *
     * @param string $current_version
     * @return array[] Array of arrays: [ 'title' => string, 'description' => string|null, 'sources' => string[] ]
     */
    public function check_vulnerabilities( $report, $current_version )
    {
        $current_version = is_string( $current_version ) ? trim( $current_version ) : '';
        if ( '' === $current_version ) {
            return [];
        }

        $results = [];
        $vulns   = isset( $report['data']['vulnerability'] ) && is_array( $report['data']['vulnerability'] )
            ? $report['data']['vulnerability']
            : [];

        foreach ( $vulns as $vuln ) {
            if ( ! $this->version_is_affected( $current_version, $vuln ) ) {
                continue;
            }

            $sources = isset( $vuln['source'] ) && is_array( $vuln['source'] ) ? $vuln['source'] : [];
            foreach ( $sources as $src ) {
                $link  = isset( $src['link'] ) ? (string) $src['link'] : '';
                $links = [];

                if ( $link ) {
                    $host = parse_url( $link, PHP_URL_HOST );
                    if ( $host ) {
                        $links[ $host ] = $link;
                    }
                }

                $results[] = [
                    'title'       => isset( $src['name'] ) ? (string) $src['name'] : '',
                    'description' => isset( $src['description'] ) ? (string) $src['description'] : null,
                    'sources'     => $links,
                    'affected_versions' => [
                        'min_version'  => isset( $vuln['operator']['min_version'] ) ? (string) $vuln['operator']['min_version'] : null,
                        'max_version'  => isset( $vuln['operator']['max_version'] ) ? (string) $vuln['operator']['max_version'] : null,
                        'min_operator' => isset( $vuln['operator']['min_operator'] ) ? (string) $vuln['operator']['min_operator'] : null,
                        'max_operator' => isset( $vuln['operator']['max_operator'] ) ? (string) $vuln['operator']['max_operator'] : null,
                    ],
                ];
            }
        }

        return $results;
    }

    /**
     * Quick boolean check.
     *
     * @param string $current_version
     * @return bool
     */
    public function has_vulnerability( $current_version ) {
        return ! empty( $this->check_vulnerabilities( $current_version ) );
    }

    /**
     * Determine if a version falls within a vulnerability's affected range.
     *
     * @param string $current_version
     * @param array  $vuln
     * @return bool
     */
    private function version_is_affected( $current_version, $vuln ) {
        $op = isset( $vuln['operator'] ) && is_array( $vuln['operator'] ) ? $vuln['operator'] : [];

        $min_version   = isset( $op['min_version'] ) && $op['min_version'] !== null ? (string) $op['min_version'] : null;
        $min_operator  = isset( $op['min_operator'] ) && $op['min_operator'] !== null ? (string) $op['min_operator'] : null;
        $max_version   = isset( $op['max_version'] ) && $op['max_version'] !== null ? (string) $op['max_version'] : null;
        $max_operator  = isset( $op['max_operator'] ) && $op['max_operator'] !== null ? (string) $op['max_operator'] : null;

        // If neither bound is present, assume not actionable.
        if ( ! $min_version && ! $max_version ) {
            return false;
        }

        $ok_min = true;
        $ok_max = true;

        if ( $min_version && $min_operator ) {
            $ok_min = $this->vcmp( $current_version, $min_operator, $min_version );
        }
        if ( $max_version && $max_operator ) {
            $ok_max = $this->vcmp( $current_version, $max_operator, $max_version );
        }

        return ( $ok_min && $ok_max );
    }

    /**
     * version_compare wrapper supporting operators found in the feed.
     *
     * Supported: lt, lte, le, gt, gte, ge, eq, ne, neq
     *
     * @param string $v1
     * @param string $operator
     * @param string $v2
     * @return bool
     */
    private function vcmp( $v1, $operator, $v2 ) {
        $map = array(
            'lt'  => '<',
            'lte' => '<=',
            'le'  => '<=',
            'gt'  => '>',
            'gte' => '>=',
            'ge'  => '>=',
            'eq'  => '==',
            'ne'  => '!=',
            'neq' => '!=',
        );

        $op = strtolower( (string) $operator );
        $op = isset( $map[ $op ] ) ? $map[ $op ] : $op;

        // Fallback: if the operator is already a valid one for version_compare.
        return (bool) version_compare( $v1, $v2, $op );
    }

    public function get_plugin_record($plugin_slug)
    {
        $url  = esc_url_raw( trailingslashit( $this->wpvulnerability_base_api_url . $plugin_slug ) );

        // Cache for 10 minutes to avoid repeated calls.
        $cache_key = 'wp_psv_' . md5( $url );
        $cached    = get_transient( $cache_key );
        if ( false !== $cached ) {
            return $cached;
        }

        $args = [
            'timeout' => 15,
            'headers' => [
                'Accept'     => 'application/json',
                'User-Agent' => 'WPVulnerability-Fetcher/' . ( defined( 'WP_DEBUG' ) && WP_DEBUG ? 'dev' : '1.0' ) . '; ' . home_url( '/' ),
            ],
        ];
        $response = wp_remote_get( $url, $args );

        if ( is_wp_error( $response ) ) {
            $data = [
                'success' => false,
                'error'   => $response->get_error_message(),
                'url'     => $url,
            ];
            set_transient( $cache_key, $data, 10 * MINUTE_IN_SECONDS );
            return $data;
        }

        $code = wp_remote_retrieve_response_code( $response );
        $body = wp_remote_retrieve_body( $response );

        if ( 200 !== (int) $code ) {
            $data = [
                'success' => false,
                'error'   => 'HTTP ' . (int) $code,
                'url'     => $url,
                'body'    => $body,
            ];
            set_transient( $cache_key, $data, 5 * MINUTE_IN_SECONDS );
            return $data;
        }

        $json = json_decode( $body, true );

        // Some endpoints may return non-JSON; handle gracefully.
        if ( JSON_ERROR_NONE !== json_last_error() ) {
            $data = [
                'success' => true,
                'raw'     => $body,
                'url'     => $url,
            ];
            set_transient( $cache_key, $data, 10 * MINUTE_IN_SECONDS );
            return $data;
        }

        $data = [
            'success' => true,
            'data'    => $json,
            'url'     => $url,
        ];
//        set_transient( $cache_key, $data, 10 * MINUTE_IN_SECONDS );

        return $data;
    }
}